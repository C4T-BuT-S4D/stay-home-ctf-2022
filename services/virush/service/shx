#!/bin/bash

if [ -z "$1" ]; then
    echo "Usage: $0 <script.shx>"
    exit 0
fi

if [ ! -r "$1" ]; then
    echo "Error: no such file"
    exit 1
fi

if [ -z "${__EXTENDED:-}" ]; then
    declare -r __EXTENDED=x

    trap "kill 0" SIGINT

    set \
        -o errexit \
        -o errtrace \
        -o noglob \
        -o nounset \
        -o pipefail

    shopt \
        -s lastpipe

    declare -r \
        STDIN=0 \
        STDOUT=1 \
        STDERR=2 \
        URANDOM="/dev/urandom" \
        DEVNULL="/dev/null"

    declare -A __MODULES=()

    @module() {
        local name=$1

        if [ -z "${__MODULES[$name]:-}" ]; then
            __MODULES[$name]=x
            return 2
        fi
    }

    declare -A __CLASSES=()

    @class() {
        local name=$1

        if [ ! -z "${__CLASSES[$name]:-}" ]; then
            return 0
        fi

        __CLASSES[$name]=x

        declare -g __INSTANCES_INDEX_$name=0

        eval "function $name::new { __INSTANCE_NEW $name \"\$@\"; }"
        eval "function $name::instance { __INSTANCE_GET $name; }"
    }

    __INSTANCE_NEW() {
        local name=$1
        local arguments=${@:2}
        local index=__INSTANCES_INDEX_$name
        local instance=__INSTANCES_${name}_${!index}

        local function
        local -a functions

        declare -F \
            | grep -P "${name}::(?!new$|instance$|delete$)" \
            | cut -d' ' -f 3 \
            | mapfile -d '' functions

        for function in $functions; do
            local -a declaration
            local -a instance_declaration

            declare -f $function | mapfile -d '' declaration

            echo "$declaration" \
                | sed "s/\b__/${instance}__/g" \
                | sed "s/\}${instance}__/\}__/g" \
                | sed "s/::${instance}__init__/::__init__/g" \
                | sed "s/::${instance}__destroy__/::__destroy__/g" \
                | sed "s/${name}::/${instance}::/g" \
                | mapfile -d '' instance_declaration

            eval "$instance_declaration"
        done

        if declare -F $instance::__init__ >$DEVNULL; then
            $instance::__init__ "$arguments"
        fi

        eval "function $instance::delete { __INSTANCE_DELETE $name $instance \"\$@\"; }"

        declare -g __INSTANCES_${name}_${!index}_FREE=x

        (( $index += 1 ))
    }

    __INSTANCE_GET() {
        local name=$1
        local index=__INSTANCES_INDEX_$name
        local instance=__INSTANCES_${name}_$(( ${!index}-1 ))
        local instance_free=${instance}_FREE

        if [ -z "${!instance_free}" ]; then
            return 1
        fi

        echo ${instance}

        unset $instance_free
    }

    __INSTANCE_DELETE() {
        local name=$1
        local instance=$2
        local arguments=${@:3}
        local instance_free=${instance}_FREE

        if [ ! -z "${!instance_free}" ]; then
            unset $instance_free
        fi

        if declare -F $instance::__destroy__ >$DEVNULL; then
            $instance::__destroy__ "$arguments"
        fi

        local function
        local -a functions

        declare -F \
            | grep "$instance" \
            | cut -d' ' -f 3 \
            | mapfile -d '' functions

        for function in $functions; do
            unset -f $function
        done

        local field
        local -a fields

        declare \
            | grep "^${instance}__" \
            | cut -d'=' -f 1 \
            | mapfile -d '' fields || true

        if [ ! -z "${fields:-}" ]; then
            for field in $fields; do
                unset $field
            done
        fi

        unset $instance
    }

    @require() {
        local name=$1

        if [ -d "$name" ]; then
            local file

            basename -- "$name" | read file
            name=$name/$file
        fi

        source "$name.shx"
    }

    @entrypoint() {
        "$@"
    }

    @module std || {
        function std::exit {
            exit "$1"
        }

        function std::raise {
            return 1
        }

        function std::hasvar {
            test ! -z "${!1:-}"
        }

        function std::hasfile {
            test -r "$1"
        }

        function std::print {
            echo "$@"
        }

        function std::sleep {
            sleep "$1"
        }
    }
fi

dirname -- $1 | read directory
basename -- $1 | read file

cd -- $directory
source -- $file
